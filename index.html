<!DOCTYPE html>
<html lang="th">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RightCode • Level&nbsp;1</title>
    <!-- Bring in Tailwind CSS for quick styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM (development builds for readability) -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>
    <!-- Babel so we can write JSX directly in the browser -->
    <script
      crossorigin
      src="https://unpkg.com/@babel/standalone/babel.min.js"
    ></script>
    <style>
      /* Disable text selection and the system lookup menu on long‑press for a smoother drag experience on iOS */
      body {
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        user-select: none;
      }
      /* Prevent images from being dragged into search on Safari */
      .no-drag {
        -webkit-user-drag: none;
        user-drag: none;
      }
    </style>
  </head>
  <body class="min-h-screen bg-gradient-to-b from-white to-slate-100 text-slate-900 p-6">
    <div id="root"></div>
    <script type="text/babel">
      {/**
       * This React component implements the Level 1 "dress‑up" puzzle.
       * It supports both mouse/desktop and touch/mobile interactions.  
       * On desktops it uses the native HTML5 drag and drop API so that an item
       * follows the cursor when dragging. On mobile/touch devices it
       * implements its own touch handlers and renders a floating preview that
       * follows the finger. A drop is detected using elementFromPoint.
       */}
      const ITEMS = [
        { id: "hat", name: "หมวก", color: "bg-amber-300", SVG: () => (
            <svg viewBox="0 0 120 80" className="w-full h-full no-drag">
              <rect x="5" y="55" width="110" height="12" rx="6" />
              <rect x="30" y="20" width="60" height="40" rx="12" />
            </svg>
          ) },
        { id: "shirt", name: "เสื้อ", color: "bg-sky-300", SVG: () => (
            <svg viewBox="0 0 120 100" className="w-full h-full no-drag">
              <path d="M20 25 L45 10 L60 25 L75 10 L100 25 L90 40 L90 90 L30 90 L30 40 Z" />
            </svg>
          ) },
        { id: "pants", name: "กางเกง", color: "bg-indigo-300", SVG: () => (
            <svg viewBox="0 0 120 100" className="w-full h-full no-drag">
              <path d="M30 10 L90 10 L85 45 L70 90 L60 90 L50 45 L45 90 L35 90 Z" />
            </svg>
          ) },
        { id: "shoes", name: "รองเท้า", color: "bg-emerald-300", SVG: () => (
            <svg viewBox="0 0 140 70" className="w-full h-full no-drag">
              <path d="M10 40 C30 20, 60 20, 70 40 L130 40 L130 55 L10 55 Z" />
            </svg>
          ) },
      ];
      const SLOTS = [
        { id: "head", accept: "hat", label: "ศีรษะ" },
        { id: "torso", accept: "shirt", label: "ลำตัว" },
        { id: "legs", accept: "pants", label: "ขา" },
        { id: "feet", accept: "shoes", label: "เท้า" },
      ];

      function BodySilhouette() {
        return (
          <svg viewBox="0 0 200 440" className="w-full h-full text-slate-600 opacity-15 no-drag">
            <circle cx="100" cy="60" r="40" />
            <rect x="55" y="110" width="90" height="120" rx="20" />
            <rect x="10" y="120" width="40" height="20" rx="10" />
            <rect x="150" y="120" width="40" height="20" rx="10" />
            <rect x="65" y="240" width="25" height="130" rx="10" />
            <rect x="110" y="240" width="25" height="130" rx="10" />
            <rect x="55" y="380" width="45" height="18" rx="9" />
            <rect x="100" y="380" width="45" height="18" rx="9" />
          </svg>
        );
      }

      function Level1DressUp() {
        const [placed, setPlaced] = React.useState({});
        const [dragOver, setDragOver] = React.useState(null);
        const [draggingId, setDraggingId] = React.useState(null);
        const [touchItem, setTouchItem] = React.useState(null);
        const [touchPos, setTouchPos] = React.useState({ x: 0, y: 0 });
        const dropZoneRefs = React.useRef({});

        const allPlaced = React.useMemo(
          () => SLOTS.every((s) => placed[s.id] === s.accept),
          [placed]
        );

        /** Handle mouse drag start. */
        const handleDragStart = (e, id) => {
          setDraggingId(id);
          // Set data for drop handlers
          e.dataTransfer.setData("text/plain", id);
          // Reset dragOver on start
          setDragOver(null);
        };
        /** Clear dragging state when the user stops dragging with mouse. */
        const handleDragEnd = () => {
          setDraggingId(null);
          setDragOver(null);
        };
        /** Handle drop from native HTML5 drag. */
        const handleDrop = (e, slotId) => {
          e.preventDefault();
          const id = e.dataTransfer.getData("text/plain");
          setDragOver(null);
          if (!id) return;
          // Find slot config
          const slot = SLOTS.find((s) => s.id === slotId);
          if (!slot) return;
          if (slot.accept !== id) {
            // Shake the drop zone to indicate incorrect placement
            const node = dropZoneRefs.current[slotId];
            if (node && node.animate) {
              node.animate(
                [
                  { transform: "translateX(0)" },
                  { transform: "translateX(-6px)" },
                  { transform: "translateX(6px)" },
                  { transform: "translateX(0)" },
                ],
                { duration: 220 }
              );
            }
            return;
          }
          if (Object.values(placed).includes(id)) return;
          setPlaced((p) => ({ ...p, [slotId]: id }));
        };
        /** Handle drag over events for mouse to allow drop. */
        const handleDragOver = (e, slotId) => {
          e.preventDefault();
          setDragOver(slotId);
        };

        // ===== Touch handlers =====
        const handleTouchStart = (id) => (e) => {
          e.preventDefault();
          setDraggingId(id);
          setTouchItem(id);
          const touch = e.touches[0];
          setTouchPos({ x: touch.clientX, y: touch.clientY });
          setDragOver(null);
        };
        const handleTouchMove = (e) => {
          if (!touchItem) return;
          const touch = e.touches[0];
          setTouchPos({ x: touch.clientX, y: touch.clientY });
          const el = document.elementFromPoint(touch.clientX, touch.clientY);
          const zoneEl = el && el.closest('[data-slot-id]');
          const slotId = zoneEl ? zoneEl.getAttribute('data-slot-id') : null;
          setDragOver(slotId);
        };
        const handleTouchEnd = (e) => {
          if (!touchItem) return;
          const touch = e.changedTouches[0];
          const el = document.elementFromPoint(touch.clientX, touch.clientY);
          const zoneEl = el && el.closest('[data-slot-id]');
          const slotId = zoneEl ? zoneEl.getAttribute('data-slot-id') : null;
          if (slotId) {
            // Use the same logic as HTML5 drop
            const slot = SLOTS.find((s) => s.id === slotId);
            if (slot && slot.accept === touchItem && !Object.values(placed).includes(touchItem)) {
              setPlaced((p) => ({ ...p, [slotId]: touchItem }));
            } else if (slot) {
              // shake wrong zone
              const node = dropZoneRefs.current[slotId];
              if (node && node.animate) {
                node.animate(
                  [
                    { transform: "translateX(0)" },
                    { transform: "translateX(-6px)" },
                    { transform: "translateX(6px)" },
                    { transform: "translateX(0)" },
                  ],
                  { duration: 220 }
                );
              }
            }
          }
          setDraggingId(null);
          setTouchItem(null);
          setDragOver(null);
        };
        /** Reset placements. */
        const reset = () => {
          setPlaced({});
          setDraggingId(null);
          setTouchItem(null);
          setDragOver(null);
        };

        /** Compute slot style positions to match silhouette. */
        const getSlotStyle = (id) => {
          switch (id) {
            case "head":
              return {
                top: "4%",
                left: "50%",
                width: "46%",
                height: "14%",
                transform: "translateX(-50%)",
              };
            case "torso":
              return {
                top: "28%",
                left: "50%",
                width: "58%",
                height: "26%",
                transform: "translateX(-50%)",
              };
            case "legs":
              return {
                top: "56%",
                left: "50%",
                width: "52%",
                height: "22%",
                transform: "translateX(-50%)",
              };
            case "feet":
              return {
                bottom: "4%",
                left: "50%",
                width: "64%",
                height: "14%",
                transform: "translateX(-50%)",
              };
            default:
              return {};
          }
        };

        return (
          <div className="max-w-6xl mx-auto">
            {/* Header with progress bar */}
            <header className="flex justify-between mb-6 items-center">
              <div>
                <h1 className="text-2xl font-bold">RightCode • Level&nbsp;1</h1>
                <p className="opacity-80 text-sm">
                  เกมลากวางแต่งตัวให้ถูกต้อง – ฝึกตรรกะพื้นฐาน
                </p>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-sm">ความคืบหน้า</span>
                <div className="w-40 h-2 bg-slate-200 rounded-full overflow-hidden">
                  <div
                    className="h-full bg-sky-500 transition-all"
                    style={{ width: `${(Object.keys(placed).length / SLOTS.length) * 100}%` }}
                  />
                </div>
              </div>
            </header>
            <div className="grid md:grid-cols-2 gap-6">
              {/* Play area */}
              <div className="relative rounded-2xl bg-white shadow p-4 select-none">
                <div className="mb-3 flex justify-between items-center">
                  <h2 className="font-semibold">พื้นที่เล่น</h2>
                  <button
                    onClick={reset}
                    className="px-3 py-1 rounded-lg bg-slate-100 hover:bg-slate-200"
                  >
                    เริ่มใหม่
                  </button>
                </div>
                <div className="relative mx-auto max-w-xs aspect-[3/5]" onTouchMove={handleTouchMove} onTouchEnd={handleTouchEnd}>
                  {/* Silhouette behind the slots */}
                  <div className="absolute inset-0 pointer-events-none">
                    <BodySilhouette />
                  </div>
                  {SLOTS.map((slot) => (
                    <div
                      key={slot.id}
                      ref={(el) => {
                        dropZoneRefs.current[slot.id] = el;
                      }}
                      data-slot-id={slot.id}
                      onDrop={(e) => handleDrop(e, slot.id)}
                      onDragOver={(e) => handleDragOver(e, slot.id)}
                      onDragEnter={(e) => e.preventDefault()}
                      className={
                        `absolute border-2 rounded-2xl flex items-center justify-center text-sm font-semibold transition-all ` +
                        (dragOver === slot.id ? `border-sky-500 bg-sky-50` : `border-slate-300/70 bg-white/60 border-dashed`)
                      }
                      style={getSlotStyle(slot.id)}
                    >
                      {!placed[slot.id] && (
                        <span className="text-slate-500 pointer-events-none">{slot.label}</span>
                      )}
                      {placed[slot.id] && (
                        <div className="w-24 h-16 flex items-center justify-center">
                          {(() => {
                            const Comp = ITEMS.find((i) => i.id === slot.accept)?.SVG;
                            return Comp ? <Comp /> : null;
                          })()}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
                <p className="text-center text-sm mt-3 opacity-80">
                  เคล็ดลับ: {dragOver ? hint[dragOver] : "ลองลากไอเท็มด้านขวาวางให้ตรงตำแหน่ง"}
                </p>
              </div>
              {/* Items area */}
              <div className="rounded-2xl bg-white shadow p-4 select-none">
                <h2 className="font-semibold mb-3 text-center">
                  ลากไอเท็มมาวางให้ถูกตำแหน่ง
                </h2>
                <div className="grid grid-cols-2 gap-3">
                  {ITEMS.map((item) => {
                    const used = Object.values(placed).includes(item.id);
                    return (
                      <div
                        key={item.id}
                        role="button"
                        className={
                          `aspect-square rounded-xl border shadow flex flex-col items-center justify-center gap-2 p-3 select-none ${item.color} ` +
                          (used ? `opacity-40 cursor-not-allowed` : `cursor-grab active:cursor-grabbing`)
                        }
                        draggable={!used}
                        onDragStart={(e) => {
                          if (!used) handleDragStart(e, item.id);
                        }}
                        onDragEnd={handleDragEnd}
                        onTouchStart={!used ? handleTouchStart(item.id) : undefined}
                      >
                        <div className="w-20 h-16 pointer-events-none">
                          <item.SVG />
                        </div>
                        <span className="font-semibold pointer-events-none">
                          {item.name}
                        </span>
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
            {/* Success overlay */}
            {allPlaced && (
              <div className="fixed inset-0 bg-black/30 flex items-center justify-center">
                <div className="bg-white rounded-3xl p-6 shadow-xl text-center max-w-sm scale-100">
                  <h3 className="text-2xl font-bold mb-2">เก่งมาก! ✓</h3>
                  <p className="mb-4 opacity-80">
                    ใส่เสื้อผ้าเสร็จเรียบร้อยแล้ว พร้อมเล่นอีกครั้ง
                  </p>
                  <div className="flex justify-center gap-2 mb-4">
                    <Star /> <Star /> <Star />
                  </div>
                  <button
                    className="px-4 py-2 bg-slate-100 rounded-lg"
                    onClick={reset}
                  >
                    เล่นอีกครั้ง
                  </button>
                </div>
              </div>
            )}
          </div>
        );
      }

      const hint = {
        head: "ลากหมวกมาวางที่หัว",
        torso: "ลากเสื้อมาวางที่ลำตัว",
        legs: "ลากกางเกงมาวางที่ขา",
        feet: "ลากรองเท้ามาวางที่เท้า",
      };

      function Star() {
        return (
          <svg
            viewBox="0 0 24 24"
            className="w-6 h-6 fill-yellow-400 stroke-yellow-500 no-drag"
          >
            <path d="M12 2l2.9 6.4 7.1.6-5.4 4.7 1.6 6.9L12 16.9 5.8 20.6l1.6-6.9L2 9l7.1-.6L12 2z" />
          </svg>
        );
      }

      // Mount the React component into the DOM
      ReactDOM.createRoot(document.getElementById('root')).render(<Level1DressUp />);
    </script>
  </body>
</html>